<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DynamicSQLBuilder.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis-scala-core</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.scala.config</a> &gt; <span class="el_source">DynamicSQLBuilder.scala</span></div><h1>DynamicSQLBuilder.scala</h1><pre class="source lang-java linenums">/*
 *    Copyright 2011-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.scala.config

import org.apache.ibatis.session.{Configuration =&gt; MBConfig}
import java.util.{List, ArrayList}
import org.apache.ibatis.scripting.xmltags._
import org.apache.ibatis.mapping.SqlSource
import scala.xml._

/** Builder of Dynamic SQL Trees. */
<span class="nc" id="L25">private[scala] class DynamicSQLBuilder(val configuration : MBConfig, val node : Node) {</span>

  /** SqlSource built from an XML Node */
  def build : SqlSource =
<span class="nc" id="L29">    new DynamicSqlSource(configuration, parse(node))</span>

  private def parse(n : Node) : SqlNode = {
<span class="nc" id="L32">    n match {</span>
<span class="nc bnc" id="L33" title="All 4 branches missed.">      case Text(text) =&gt;</span>
<span class="nc" id="L34">        new TextSqlNode(text)</span>
<span class="nc bnc" id="L35" title="All 4 branches missed.">      case PCData(text) =&gt;</span>
<span class="nc" id="L36">        new TextSqlNode(text)</span>
<span class="nc bnc" id="L37" title="All 6 branches missed.">      case &lt;xsql&gt;{children @ _*}&lt;/xsql&gt; =&gt;</span>
<span class="nc" id="L38">        parseChildren(children)</span>
<span class="nc bnc" id="L39" title="All 6 branches missed.">      case trim @ &lt;trim&gt;{children @ _*}&lt;/trim&gt; =&gt;</span>
<span class="nc" id="L40">        val content = parseChildren(children)</span>
<span class="nc" id="L41">        new TrimSqlNode(</span>
<span class="nc" id="L42">          configuration,</span>
<span class="nc" id="L43">          content,</span>
<span class="nc" id="L44">          attr(trim, &quot;@prefix&quot;),</span>
<span class="nc" id="L45">          attr(trim, &quot;@prefixOverrides&quot;),</span>
<span class="nc" id="L46">          attr(trim, &quot;@suffix&quot;),</span>
<span class="nc" id="L47">          attr(trim, &quot;@suffixOverrides&quot;)</span>
        )
<span class="nc bnc" id="L49" title="All 6 branches missed.">      case &lt;where&gt;{children @ _*}&lt;/where&gt; =&gt;</span>
<span class="nc" id="L50">        val content = parseChildren(children)</span>
<span class="nc" id="L51">        new WhereSqlNode(configuration, content)</span>
<span class="nc bnc" id="L52" title="All 6 branches missed.">      case &lt;set&gt;{children @ _*}&lt;/set&gt; =&gt;</span>
<span class="nc" id="L53">        val content = parseChildren(children)</span>
<span class="nc" id="L54">        new SetSqlNode(configuration, content)</span>
<span class="nc bnc" id="L55" title="All 6 branches missed.">      case foreach @ &lt;foreach&gt;{children @ _*}&lt;/foreach&gt; =&gt;</span>
<span class="nc" id="L56">        val content = parseChildren(children)</span>
<span class="nc" id="L57">        new ForEachSqlNode(</span>
<span class="nc" id="L58">          configuration,</span>
<span class="nc" id="L59">          content,</span>
<span class="nc" id="L60">          attr(foreach, &quot;@collection&quot;),</span>
<span class="nc" id="L61">          attr(foreach, &quot;@index&quot;),</span>
<span class="nc" id="L62">          attr(foreach, &quot;@item&quot;),</span>
<span class="nc" id="L63">          attr(foreach, &quot;@open&quot;),</span>
<span class="nc" id="L64">          attr(foreach, &quot;@close&quot;),</span>
<span class="nc" id="L65">          attr(foreach, &quot;@separator&quot;))</span>
<span class="nc bnc" id="L66" title="All 6 branches missed.">      case ifNode @ &lt;if&gt;{children @ _*}&lt;/if&gt; =&gt;</span>
<span class="nc" id="L67">        val content = parseChildren(children)</span>
<span class="nc" id="L68">        new IfSqlNode(content, attr(ifNode, &quot;@test&quot;))</span>
<span class="nc bnc" id="L69" title="All 6 branches missed.">      case &lt;choose&gt;{children @ _*}&lt;/choose&gt; =&gt;</span>
<span class="nc" id="L70">        val ifNodes = new ArrayList[SqlNode]</span>
<span class="nc" id="L71">        var defaultNode : MixedSqlNode = null</span>
<span class="nc" id="L72">        for (child &lt;- children) {</span>
<span class="nc" id="L73">          child match {</span>
<span class="nc bnc" id="L74" title="All 6 branches missed.">            case when @ &lt;when&gt;{ch @ _*}&lt;/when&gt; =&gt; {</span>
<span class="nc" id="L75">              val content = parseChildren(ch)</span>
<span class="nc" id="L76">              ifNodes add new IfSqlNode(content, attr(when, &quot;@test&quot;))</span>
            }
<span class="nc bnc" id="L78" title="All 6 branches missed.">            case other @ &lt;otherwise&gt;{ch @ _*}&lt;/otherwise&gt; =&gt;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">              if (defaultNode == null)</span>
<span class="nc" id="L80">                defaultNode = parseChildren(ch)</span>
              else
<span class="nc" id="L82">                throw new ConfigurationException(&quot;Too many default (otherwise) elements in choose statement.&quot;)</span>
                //error(&quot;Too many default (otherwise) elements in choose statement.&quot;)
<span class="nc" id="L84">            case _ =&gt;</span>
          }
        }
<span class="nc" id="L87">        new ChooseSqlNode(ifNodes, defaultNode)</span>
<span class="nc bnc" id="L88" title="All 6 branches missed.">      case ifNode @ &lt;when&gt;{children @ _*}&lt;/when&gt; =&gt;</span>
<span class="nc" id="L89">        val content = parseChildren(children)</span>
<span class="nc" id="L90">        new IfSqlNode(content, attr(ifNode, &quot;@test&quot;))</span>
<span class="nc bnc" id="L91" title="All 6 branches missed.">      case other @ &lt;otherwise&gt;{children @ _*}&lt;/otherwise&gt; =&gt;</span>
<span class="nc" id="L92">        parseChildren(other)</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">      case a : Atom[_] =&gt;</span>
<span class="nc" id="L94">        new TextSqlNode(a.data.asInstanceOf[String])</span>
<span class="nc bnc" id="L95" title="All 10 branches missed.">      case bind @ &lt;bind /&gt; =&gt;</span>
<span class="nc" id="L96">        new VarDeclSqlNode(attr(bind, &quot;@name&quot;), attr(bind, &quot;@value&quot;))</span>
      case unsupported =&gt;
<span class="nc" id="L98">        throw new ConfigurationException(&quot;Unknown element &quot; + unsupported.getClass.getName + &quot; in SQL statement.&quot;)</span>
        //error(&quot;Unknown element &quot; + unsupported.toString + &quot; in SQL statement.&quot;)
    }
  }

  private def parseChildren(children : Seq[Node]) : MixedSqlNode = {
<span class="nc" id="L104">    val nodes = new ArrayList[SqlNode]</span>
<span class="nc" id="L105">    for (child &lt;- children) {</span>
<span class="nc" id="L106">      nodes add parse(child)</span>
    }
<span class="nc" id="L108">    new MixedSqlNode(nodes)</span>
  }

  private def attr(n : Node, name : String) : String = {
<span class="nc bnc" id="L112" title="All 4 branches missed.">    (n \ name).text match {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      case &quot;&quot; =&gt; null</span>
<span class="nc" id="L114">      case text =&gt; text</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>